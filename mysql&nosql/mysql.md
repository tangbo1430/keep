# MySQL数据库经典面试题解析

### 一、MySQL 索引使用有哪些注意事项呢？

​	可以从三个维度回答这个问题：索引哪些情况会失效，索引不适合哪些场景，索引规则

- ##### 索引哪些情况会失效

  - 查询条件包含or，可能导致索引失效
  - 字符串类型，where时，如果不用引号括起来，会导致类型转换，从而索引失效
  - like以通配符 % 开头的索引会失效，当我们使用了左模糊匹配和左右模糊匹配的时候，像like ‘%str’或者‘%str%’。
  - 使用联合索引，查询时条件列不是联合索引中的一个列。不符合最左前缀原则，索引失效
  - 在索引列上使用mysql内置函数，导致失效
  - 对索引列使用运算符（+、-、*、/）
  - 对索引列使用（!=、<>、not in）
  - 对索引列使用is null、is not null
  - 连接查询，查询关联的字段编码格式不一样
  - 当mysql判断全表扫描比使用索引快时，则不使用索引

- ##### 索引不适合哪些场景

  - 全表数据量少，建索引得不偿失
  - 更新频繁的字段
  - 区分度低的字段（如性别，平均分）

- ##### 索引的一些潜规则

  - 索引覆盖
  - 回表
  - 索引结构
  - 最左前缀原则
  - 索引下推

### 二、MySQL 遇到过死锁问题吗，你是如何解决的？

##### 	排查死锁的流程一般如下：

- 查看死锁日志show engine innodb status
- 找出死锁sql
- 分析sql加锁情况
- 模拟死锁案发
- 分析死锁日志
- 分析死锁结果

### 三、日常工作中你是如何优化sql的?

1. 对查询频繁的字段上索引
2. 避免返回不必要的数据，只select必要数据
3. 适当分批量查询
4. 优化sql结构
5. 分库分表
6. 读写分离
7. 不怎么更新的数据加载到内存，高频访问数据做缓存

### 四、说说你是怎么设计分库与分表的

- 水平分库：以字段（如cid）为依据，按照一定策略（hash、range等），将一个库中的数据拆分到多个库中
- 水平分表：以字段（如cid）为依据，按照一定策略（hash、range等），将一个表中的数据拆分到多个表中
- 垂直分库：以表为依据，按照业务归属不同，把一个库中的表拆到各自业务的库中
- 垂直分表：以字段为依据，按照字段的活跃性，将表中字段拆到不同的表（主表和扩展表），例如（appinfo和appinfoExtend）

##### 	常用分库分表中间件：

1. sharding-jdbc（当当）
2. Mycat
3. TDDL（淘宝）
4. Oceanus（58同城）
5. vitess（谷歌）
6. Atlas（奇虎360）

##### 	分库分表可能会遇到的问题

1. 事务问题：需要分布式事务
2. 跨节点join问题，需要分两次查询才能解决
3. 跨节点的count,order by,group by以及聚合函数问题：分别在各个节点上得到结果后在<u>内存进行合并</u>。
4. 数据迁移，容量规划，扩容等问题
5. id问题，数据库切分后不能按照数据库自身的主键生成机制了，可以考虑雪花id或者uuid，或者自定义复合主键
6. 跨分片的排序分页问题

### 五、InnoDB与MyISAM的区别

- InnoDB支持事务，MyISAM不支持事务
- InnoDB支持外键，MyISAM不支持外键
- InnoDB支持MVVC（多版本并发控制），MyISAM不支持
- select count(*) from table时，MyISAM更快，因为它有一个变量保存了整个表的总行数，可以直接读取，InnoDB需要全表扫描
- mysql5.7以前，innoDB不支持全文索引，MyISAM支持全文索引
- InnoDB支持表、行级锁，而MyISAM仅支持表锁
- InnoDB必须要有主键，而MyISAM可以没有
- InnoDB表需要更多的内存和存储，而MyISAM可被压缩，存储空间小
- InnoDB表按主键大小有序插入，MyISAM记录插入顺序则是，按记录插入顺序保存
- InnoDB提供了回滚、提交事务、崩溃恢复能力，与MyISAM比，InnoDB写的效率差一点，并且会占用更多磁盘空间用来保存索引和数据
- InnoDB属于索引组织表，使用共享表空间和多表空间存储数据，MyISAM用.frm、.MYD、.MTI来存储表定义、数据和索引

### 六、数据库索引的原理，为什么要用B+树，为什么不用二叉树？

​	可以从多个维度看这个问题，查询是否够快，效率是否稳定，存储数据多少，以及查找磁盘次数，为什么不是二叉树，为什么不是平衡二叉树，为什么不是B树，偏偏是B+树呢？

##### 	为什么不是一般的二叉树？

​	如果二叉树特殊化（退化，只有左孩子或者只有右孩子）为一个链表，相当于全表扫描，平衡二叉树相比于二叉查找树而言，查找效率更稳定，总体速度也快

##### 	为什么不是平衡二叉树？

​	在内存比在磁盘的数据，查询效率高很多，如果用平衡二叉树作为索引结构，每查找一次数据就要从磁盘读一个节点，也就是磁盘块，但是平衡二叉树每个节点只存储一个键值和数据，如果是B树，可以存储更多的节点数据，树的高度也会降低，因此读取磁盘的次数就变少了，查询效率嘎嘎提高

##### 	为什么不是B树？

1. B+树非叶子节点上是不存储数据的，仅存储简直，而B树节点不仅存储键值，也存储数据，innodb中页的默认大小是16kb，如果不存储数据，那么就会存储更多的键值，相应树的阶树（节点的子节点数）就会更大，树就会更矮更胖，如此一来我们进行磁盘的i/o次数也会减少，查询效率会更高
2. B+树索引的所有数据均存储在叶子节点，而且数据是按照顺序排列的，链表连着叶子节点，所以B+树能更好支持范围查找，排序查找，分组查找与去重

### 七、聚集索引与非聚集索引区别

1. 一个表中只能有一个聚集索引，而非聚集索引一个表可以存在多个
2. 聚集索引，索引中键值的逻辑顺序决定了表中相应行的物理顺序；非聚集索引，索引的逻辑顺序与磁盘上行的物理存储顺序不同
3. 索引通过二叉树的数据结构来描述，我们可以这么理解聚集索引：索引的叶子节点就是数据节点，而非聚集索引的叶子节点仍然是索引节点，只不过有一个指针指向对应的数据块。
4. 聚集索引物理存储按照索引排序，非聚集索引物理存储不按照索引排序

​	何时使用聚集索引和非聚集索引?

| 动作描述           | 聚集索引 | 非聚集索引 |
| ------------------ | -------- | ---------- |
| 列经常被分组排序   | 可使用   | 可使用     |
| 返回某范围内的数据 | 可使用   | 不可       |
| 一个或极少不同值   | 不可     | 不可       |
| 小数目的不同值     | 可使用   | 不可       |
| 大数目的不同值     | 不可     | 可使用     |
| 频繁更新的列       | 不可     | 可使用     |
| 外键列             | 可使用   | 可使用     |
| 主键列             | 可使用   | 可使用     |
| 频繁修改索引列     | 不可     | 可使用     |

### 八、limit 1000000 加载很慢的话，你是怎么解决的呢？

```sql
CREATE TABLE `users` (
  `id` bigint(20) NOT NULL AUTO_INCREMENT,
  `username` varchar(255) DEFAULT NULL,
  `email` varchar(255) DEFAULT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=1000001 DEFAULT CHARSET=utf8;

// 如果列较少，可以创建覆盖索引，直接全查，走索引快得很
CREATE INDEX idx_users_id_username_email ON users(id, username, email);

SELECT id, username, email FROM users ORDER BY id LIMIT 1000000, 10;
```

##### 方案一：如果id是连续的，可以分批循环查询，返回上次查询的最大记录（偏移量），再往下limit。（如应用市场，查询一百张appmarket表）

```mysql
select id,username from users where id > （上一次循环查询的最大id） limit 1000
```

##### 方案二：在业务允许的条件下，限制页数

##### 方案三：order by + 索引 （id为索引）

```mysql
select id,username from users order by id limit 1000000，10
SELECT a.* FROM employee a, (select id from employee where 条件 LIMIT 1000000,10 ) b where a.id=b.id
```

##### 方案四：使用分区表，你可以按照ID的范围来分区你的表。然后，你的查询可以只扫描一个分区，而不是整个表。

### 九、如何选择合适的分布式主键方案?

- 数据库自增长序列或者字段
- uuid
- redis生成id，所有服务都依赖于redis生成id
- twitter的snowflake算法（雪花算法）
- 利用zookeeper生成唯一id
- monogDB的objectId

### 十、大表查询优化方案？

1. 优化shema、sql语句+索引
2. memcached，redis缓存，内存缓存，多级缓存插件
3. 主从复制，读写分离
4. 分库分表，sharding分片

### 十一、事务隔离级别

1. 读未提交（脏读）
2. 读已提交（不可重读）
3. 可重复读（幻读）
4. 串行化

##### 	mysql默认的事务隔离级别是可重复读

### 十二、什么是幻读、脏读、不可重复读？

- 脏读：事务A、B交替执行，事务A被事务B干扰到了，因为事务A读取到事务B未提交的数据，就是脏读
- 不可重读：在一个事务范围内，两个相同的查询，读取同一条记录，却返回了不同数据
- 幻读：事务A查询一个范围的结果集，另一个并发事务B往这个范围中插入/删除了值，并悄悄提交，然后事务A再次查询相同范围，两次读到的结果集不一致，这既是幻读

### 十三、在高并发情况下，如何做到安全的修改同一行数据？

​	要安全的修改同一行数据，就要保证一个线程在修改时，其他线程无法更新该条记录，一版有【乐观锁】和【悲观锁】两种方案

1. 乐观锁的思想基于，当线程请求过来，先放过去执行，如果看到别的线程没修改过，就可以修改成功，如果别的线程修改过，就失败或者重试，实现方式一般基于版本号机制或CAS算法实现

   场景：

   - 高响应效率
   - 冲突频率低，乐观锁会导致多次失败
   - 会导致用户重新执行

   ```mysql
   1.select version where id = 1; // version = "1.0"
   
   2.update user set username = "shybo" where id = 1 and version = "1.0"
   ```

2. 乐观锁的思想其实就是排他锁，当一个线程在执行时，其他线程阻塞

   ```mysql
   // 这条sql锁定了user表中符合检索条件 username = "shybo" 的记录，本次事务提交前，其他线程无法更改
   select * from user where username = "shybo" for update
   ```

   - 冲突频率高
   - 重试代价大时，选悲观锁，因为悲观锁会阻塞等待

### 十四、你在工作中如何优化sql，怎么查看执行计划（explain）

1. show status 命令了解各种sql的执行频率
2. 通过慢查询日志定位那些执行效率低的sql
3. explain分析sql，分析sql是否走了索引，影响行数

### 十五、select for update有什么含义，会锁表还是锁行还是其他？

##### 	select for updata 含义

​	select查询语句是不会加锁的，但是select for update除了有查询的作用外，还会加速，至于加了行锁还是表锁，这就要看是不是使用了索引/主键，没用到索引/主键的话就是表锁，用到了就是行锁

### 十六、mysql事务的四大特性以及实现原理

1. 原子性：事务作为一个整体被执行，包含其中的对数据的操作，要么全部执行，要么都不执行
   - 使用undo log实现，如果事务执行过程中出错或者用户执行了回滚，系统通过undo log日志返回事务开始前的状态
2. 一致性：指在事务开始之前和结束之后，数据不会被破坏，假如a账户给b账户转账10元，不管成功与否，a+b的总金额是不会变的
   - 通过回滚、恢复以及并发情况下的隔离性，从而实现一致
3. 隔离性：多个事务并发访问时，事务之间是相互隔离的，即一个事务不影响其他事务的运行，事务之间井水不犯河水
   - 通过锁以及mvcc隔离
4. 持久性：事务完成后，该事务对数据库所做的操作，将持久的保存在数据库（磁盘）中
   - 使用redo log实现，只要redo log日志持久化了，当系统崩溃，即可通过redo log把数据恢复

### 十七、如果某个表有近千万条数据，crud比较慢，如何优化？

- 分库分表（水平分表、垂直分表，切分规则hash等）
- 分库分表中间件
- 优化表结构，索引设计，查询不要select *，只选必要字段

### 十八、如何写sql能够有效的使用到复合索引

##### 	复合索引也叫组合索引，用户可以在多个列上建立索引

```mysql
// 索引为 (k1,k2,k3)相当于k1、(k1,k2)、(k1,k2,k3)，最左前缀原则
select * from user where k1 = A AND k2 = b AND k3 = C
```

​	需要严格遵循sql条件的顺序，确保复合最左前缀原则

### 十九、数据库自增主键可能遇到什么问题。

​	使用自增主键对数据库做分库分表，可能出现主键重复，自增主键会产生表锁，做大数据迁移会不友好，自增主键还可能用完

### 二十、mvcc熟悉吗，它的底层原理？

​	mvcc，多版本并发控制，它是通过读取历史版本的数据，来降低并发事务冲突，从而提高并发性的一种机制

##### 	需要关注的知识点:

1. 事务版本号
2. 表的隐藏列
3. undo log
4. read view

### 二十一、数据库中间件了解吗，sharding jdbc，mycat？

​	sharding-jdbc是基于jdbc驱动，无需额外的proxy，因此也无需关注proxy本身的高可用，mycat是基于proxy，它复写了mysql的协议，将mycat server伪装成一个mysql数据库，而sharding-jdbc是基于jdbc接口实现，是以jar包的形式提供轻量级服务

### 二十二、mysql中in和exists的区别

​	假设表A表示某企业的员工表，表B表示部门表，查询所有部门的所有员工，很容易有以下SQL:

```mysql
select * from A where deptId in (select deptId from B);
```

等价于

```java
// 先查询部门表B select deptId from B 再由部门deptId，查询A的员工 select * from A where A.deptId = B.deptId  
List<> resultSet ;
    for(int i=0;i<B.length;i++) {
          for(int j=0;j<A.length;j++) {
          if(A[i].id==B[j].id) {
             resultSet.add(A[i]);
             break;
          }
       }
    }
```

除了使用in，我们也可以用exists实现一样的查询功能，如下：

```mysql
select * from A where exists (select 1 from B where A.deptId = B.deptId); 
```

```java
// exists查询的理解就是，先执行主查询，获得数据后，再放到子查询中做条件验证，根据验证结果（true或者false），来决定主查询的数据结果是否得意保留。
// select * from A,先从A表做循环 select * from B where A.deptId = B.deptId,再从B表做循环.

 List<> resultSet ;
    for(int i=0;i<A.length;i++) {
          for(int j=0;j<B.length;j++) {
          if(A[i].deptId==B[j].deptId) {
             resultSet.add(A[i]);
             break;
          }
       }
    }
```

​	数据库最费劲的就是跟程序链接释放。假设链接了两次，每次做上百万次的数据集查询，查完就走，这样就只做了两次；相反建立了上百万次链接，申请链接释放反复重复，这样系统就受不了了。即mysql优化原则，就是小表驱动大表，小的数据集驱动大的数据集，从而让性能更优。 **因此，我们要选择最外层循环小的，也就是，如果B的数据量小于A，适合使用in，如果B的数据量大于A，即适合选择exists，这就是in和exists的区别。**

##### 	遵循小表驱动大表的原则！

### 二十三、InnoDB引擎的索引策略？

1. 索引覆盖
2. 最左前缀原则
3. 索引下推
4. 索引下推优化是 MySQL 5.6 引入的， 可以在索引遍历过程中，对索引中包含的字段先做判断，直接过滤掉不满足条件的记录，减少回表次数

### 二十四、数据库存储日期格式时，如何考虑时区转换问题？

1. ##### datetime类型适合用来记录数据的原始的创建时间，修改记录中其他字段的值，datetime字段的值不会改变，除非手动修改它

2. ##### timestamp类型适合用来记录数据的最后修改时间，只要修改了记录中其他字段的值，timestamp字段的值都会被自动更新

### 二十五、一条sql执行时间很长，你如何优化，从哪些方面入手？

1. 查看是否涉及多表和子查询，优化sql结构，去重冗余字段，拆表
   - 如果涉及多表以及子查询，看是否遵循小表驱动大表的原则
   - select时，不要查询冗余的字段，只查询关键字段如id等
   - 垂直分表，将额外信息拆到另外一张表，主表存简短的主要信息
2. 优化索引结构，去重不合理的索引，索引尽量覆盖查询条件，走覆盖索引效率极高
3. 数据库主从分离，读写分离
4. explain分析sql，到底有没有走索引，是不是sql有问题

### 二十六、mysql数据库性能分析的方法命令？

- show status 一些值的监控的变量值

  > Bytes_received和Bytes_sent 和服务器之间来往的流量。 Com_*服务器正在执行的命令。 Created_*在查询执行期限间创建的临时表和文件。 Handler_*存储引擎操作。 Select_*不同类型的联接执行计划。 Sort_*几种排序信息。

- Show profiles 是MySql用来分析当前会话SQL语句执行的资源消耗情况

### 二十七、Blob和text有什么区别？

- Blob用于存储二进制数据，而test用于存大字符串
- Blob值被视为二进制字符串（字节字符串）,它们没有字符集，并且排序和比较基于列值中的字节的数值。
- text值被视为非二进制字符串（字符字符串）。它们有一个字符集，并根据字符集的排序规则对值进行排序和比较。

### 二十八、mysql里用什么字段类型记录货币好？

1. 货币一般用Decimal和Numric类型表示
2. salary， DECIMAL(9,2)，9(precision)代表将被用于存储值的总的小数位数，而2(scale)代表将被用于存储小数点后的位数。存储在salary列中的值的范围是从-9999999.99到9999999.99。
3. DECIMAL和NUMERIC值作为字符串存储，而不是作为二进制浮点数，以便保存那些值的小数精度。

### 二十九、Hash索引和B+树的区别是什么？你在设计索引时怎么选择?

- B+树可以范围查找，Hash索引不行
- B+树支持联合索引查找的最左前缀原则，Hash索引不支持
- B+树支持order by排序，Hash索引不支持
- Hash索引在等值查询上比B+树效率高
- B+树使用like进行模糊查询，右匹配模糊（like data+"%"）的话可以起作用,data可以前缀索引到，Hash索引支持不了一点模糊

### 三十、mysql 的内连接、左连接、右连接有什么区别？

- Inner join 内连接，在两张表进行连接查询时，只保留两张表中完全匹配的结果集
- left join 在两张表进行连接查询时，会返回左表所有的行，即使在右表中没有匹配的记录。
- right join 在两张表进行连接查询时，会返回右表所有的行，即使在左表中没有匹配的记录。

### 三十一、说一下数据库三大范式？

- 第一范式：数据表中的每一列（每个字段）都不可以再拆分
- 第二范式：在第一范式的基础上，分主键列完全依赖于主键，而不能是依赖于主键的一部分
- 第三范式：在第二范式基础上，表中的非主键只依赖于主键，而不依赖于其他非主键

### 三十二、mysql的binlog有几种录入格式？分别有什么区别？

1. statement，每一条会修改数据的sql都会记录在binlog中。不需要记录没一行的变化，减少了binlog的日志量，节约i/o，提高性能。由于sql的执行是有上下文的，因此在保存的时候需要保存相关的信息，同时还有一些使用了函数之类的语句无法被记录复制。
2. row，不记录sql语句上下文相关信息，仅记录哪条记录被修改。记录单元为每一行的改动，基本上可以全部记下来，但是由于很多操作，导致大量行的改动，此模式信息量大，资源消耗大。
3. mixed，一种折中方式，普通操作使用statement，当无法使用statement就使用row

### 三十三、InnoDB引擎的四大特性了解吗？

- 插入缓存
- 二次写
- 自适应哈希索引
- 预读

### 三十四、百万级别数据删除？

1. 先删除索引
2. 删除数据
3. 重建索引

### 三十五、覆盖索引、回表是什么意思?

- 覆盖索引：查询列要被所建的索引覆盖，不必从数据表中读取数据，数据直接从索引信息里拿，简单来说就是只查有索引的数据
- 回表：二级索引无法直接查询所有列的数据，通过二级索引查询到聚簇索引后，在查询到想要的数据，通过二级索引查询出来的结果，叫回表。（比如先筛选did，再查name）

### 三十六、B+树在满足聚簇索引和覆盖索引的时候不需要回表查询数据

- 在B+树的索引中，叶子节点可能存储了当前的key值，也可能存储了当前的key值以及整行的数据，这就是聚簇索引和非聚簇索引。 在InnoDB中，只有主键索引是聚簇索引，如果没有主键，则挑选一个唯一键建立聚簇索引。如果没有唯一键，则隐式的生成一个键来建立聚簇索引。
- 当查询使用聚簇索引时，在对应的叶子节点，可以获取到整行数据，因此不用再次进行回表查询。

### 三十七、非聚簇索引一定会回表查询吗？

​	不一定，如果查询语句的字段全部命中了索引，那么就不必再进行回表查询。举个简单的例子，假设我们在学生表的age上建立了索引，那么当进行`select age from student where age < 20`的查询时，在索引的叶子节点上，已经包含了age信息，不会再次进行回表查询。

### 三十八、什么是死锁？

##### 	死锁是指两个或多个事务在同一资源上相互占用，并请求锁定对方的资源，从而导致恶性循环的现象。

​	死锁有四个必要条件：**互斥条件，请求和保持条件，环路等待条件，不剥夺条件**。 解决死锁思路，一般就是切断环路，尽量避免并发形成环路。

- 如果不同程序会并发存取多个表，尽量约定以相同的顺序访问表，可以大大降低死锁机会。
- 在同一个事务中，尽可能做到一次锁定所需要的所有资源，减少死锁产生概率；
- 对于非常容易产生死锁的业务部分，可以尝试使用升级锁定颗粒度，通过表级锁定来减少死锁产生的概率；
- 如果业务处理不好可以用分布式事务锁或者使用乐观锁
- 死锁与索引密不可分，解决索引问题，需要合理优化你的索引

### 三十九、count(1)、count(*) 与 count(列名) 的区别？

- count(*)包括了所有的列，相当于行数，在统计结果的时候，不会忽略列值为NULL
- count(1)包括了忽略所有列，用1代表代码行，在统计结果的时候，不会忽略列值为NULL
- count(列名)只包括列名那一列，在统计结果的时候，会忽略列值为空（这里的空不是只空字符串或者0，而是表示null）的计数，即某个字段值为NULL时，不统计。

### 四十、sql约束有哪些?

- NOT NULL: 约束字段的内容一定不能为NULL。
- UNIQUE: 约束字段唯一性，一个表允许有多个 Unique 约束。
- PRIMARY KEY: 约束字段唯一，不可重复，一个表只允许存在一个。
- FOREIGN KEY: 用于预防破坏表之间连接的动作，也能防止非法数据插入外键。
- CHECK: 用于控制字段的值范围。

### 四十一、drop、delete与truncate的区别

|          | delete                                   | truncate                       | drop                                                 |
| -------- | ---------------------------------------- | ------------------------------ | ---------------------------------------------------- |
| 类型     | DML                                      | DDL                            | DDL                                                  |
| 回滚     | 可回滚                                   | 不可回滚                       | 不可回滚                                             |
| 删除内容 | 表结构还在，删除表的全部或者一部分数据行 | 表结构还在，删除表中的所有数据 | 从数据库中删除表，所有的数据行，索引和权限也会被删除 |
| 删除速度 | 删除速度慢，逐行删除                     | 删除速度快                     | 删除速度最快                                         |

### 四十二、UNION与UNION ALL的区别？

- Union：对两个结果集进行并集操作，不包括重复行，同时进行默认规则的排序；
- Union All：对两个结果集进行并集操作，包括重复行，不进行排序；
- UNION的效率高于 UNION ALL
