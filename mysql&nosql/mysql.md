# MySQL数据库经典面试题解析

### 一、MySQL 索引使用有哪些注意事项呢？

​	可以从三个维度回答这个问题：索引哪些情况会失效，索引不适合哪些场景，索引规则

- ##### 索引哪些情况会失效

  - 查询条件包含or，可能导致索引失效
  - 字符串类型，where时，如果不用引号括起来，会导致类型转换，从而索引失效
  - like以通配符 % 开头的索引会失效
  - 使用联合索引，查询时条件列不是联合索引中的一个列。不符合最左前缀原则，索引失效
  - 在索引列上使用mysql内置函数，导致失效
  - 对索引列使用运算符（+、-、*、/）
  - 对索引列使用（!=、<>、not in）
  - 对索引列使用is null、is not null
  - 连接查询，查询关联的字段编码格式不一样
  - 当mysql判断全表扫描比使用索引快时，则不使用索引

- ##### 索引不适合哪些场景

  - 全表数据量少，建索引得不偿失
  - 更新频繁的字段
  - 区分度低的字段（如性别，平均分）

- ##### 索引的一些潜规则

  - 索引覆盖
  - 回表
  - 索引结构
  - 最左前缀原则
  - 索引下推

### 二、MySQL 遇到过死锁问题吗，你是如何解决的？

##### 	排查死锁的流程一般如下：

- 查看死锁日志show engine innodb status
- 找出死锁sql
- 分析sql加锁情况
- 模拟死锁案发
- 分析死锁日志
- 分析死锁结果

### 三、日常工作中你是如何优化sql的?

1. 对查询频繁的字段上索引
2. 避免返回不必要的数据，只select必要数据
3. 适当分批量查询
4. 优化sql结构
5. 分库分表
6. 读写分离
7. 不怎么更新的数据加载到内存，高频访问数据做缓存

### 四、说说你是怎么设计分库与分表的

- 水平分库：以字段（如cid）为依据，按照一定策略（hash、range等），将一个库中的数据拆分到多个库中
- 水平分表：以字段（如cid）为依据，按照一定策略（hash、range等），将一个表中的数据拆分到多个表中
- 垂直分库：以表为依据，按照业务归属不同，把一个库中的表拆到各自业务的库中
- 垂直分表：以字段为依据，按照字段的活跃性，将表中字段拆到不同的表（主表和扩展表），例如（appinfo和appinfoExtend）

##### 	常用分库分表中间件：

1. sharding-jdbc（当当）
2. Mycat
3. TDDL（淘宝）
4. Oceanus（58同城）
5. vitess（谷歌）
6. Atlas（奇虎360）

##### 	分库分表可能会遇到的问题

1. 事务问题：需要分布式事务
2. 跨节点join问题，需要分两次查询才能解决
3. 跨节点的count,order by,group by以及聚合函数问题：分别在各个节点上得到结果后在<u>内存进行合并</u>。
4. 数据迁移，容量规划，扩容等问题
5. id问题，数据库切分后不能按照数据库自身的主键生成机制了，可以考虑雪花id或者uuid，或者自定义复合主键
6. 跨分片的排序分页问题

### 五、InnoDB与MyISAM的区别

- InnoDB支持事务，MyISAM不支持事务
- InnoDB支持外键，MyISAM不支持外键
- InnoDB支持MVVC（多版本并发控制），MyISAM不支持
- select count(*) from table时，MyISAM更快，因为它有一个变量保存了整个表的总行数，可以直接读取，InnoDB需要全表扫描
- mysql5.7以前，innoDB不支持全文索引，MyISAM支持全文索引
- InnoDB支持表、行级锁，而MyISAM仅支持表锁
- InnoDB必须要有主键，而MyISAM可以没有
- InnoDB表需要更多的内存和存储，而MyISAM可被压缩，存储空间小
- InnoDB表按主键大小有序插入，MyISAM记录插入顺序则是，按记录插入顺序保存
- InnoDB提供了回滚、提交事务、崩溃恢复能力，与MyISAM比，InnoDB写的效率差一点，并且会占用更多磁盘空间用来保存索引和数据
- InnoDB属于索引组织表，使用共享表空间和多表空间存储数据，MyISAM用.frm、.MYD、.MTI来存储表定义、数据和索引

### 六、数据库索引的原理，为什么要用B+树，为什么不用二叉树？

​	可以从多个维度看这个问题，查询是否够快，效率是否稳定，存储数据多少，以及查找磁盘次数，为什么不是二叉树，为什么不是平衡二叉树，为什么不是B树，偏偏是B+树呢？

##### 	为什么不是一般的二叉树？

​	如果二叉树特殊化（退化，只有左孩子或者只有右孩子）为一个链表，相当于全表扫描，平衡二叉树相比于二叉查找树而言，查找效率更稳定，总体速度也快

##### 	为什么不是平衡二叉树？

​	在内存比在磁盘的数据，查询效率高很多，如果用平衡二叉树作为索引结构，每查找一次数据就要从磁盘读一个节点，也就是磁盘块，但是平衡二叉树每个节点只存储一个键值和数据，如果是B树，可以存储更多的节点数据，树的高度也会降低，因此读取磁盘的次数就变少了，查询效率嘎嘎提高

##### 	为什么不是B树？

1. B+树非叶子节点上是不存储数据的，仅存储简直，而B树节点不仅存储键值，也存储数据，innodb中页的默认大小是16kb，如果不存储数据，那么就会存储更多的键值，相应树的阶树（节点的子节点数）就会更大，树就会更矮更胖，如此一来我们进行磁盘的i/o次数也会减少，查询效率会更高
2. B+树索引的所有数据均存储在叶子节点，而且数据是按照顺序排列的，链表连着叶子节点，所以B+树能更好支持范围查找，排序查找，分组查找与去重

### 七、聚集索引与非聚集索引区别

1. 一个表中只能有一个聚集索引，而非聚集索引一个表可以存在多个
2. 聚集索引，索引中键值的逻辑顺序决定了表中相应行的物理顺序；非聚集索引，索引的逻辑顺序与磁盘上行的物理存储顺序不同
3. 索引通过二叉树的数据结构来描述，我们可以这么理解聚集索引：索引的叶子节点就是数据节点，而非聚集索引的叶子节点仍然是索引节点，只不过有一个指针指向对应的数据块。
4. 聚集索引物理存储按照索引排序，非聚集索引物理存储不按照索引排序

​	何时使用聚集索引和非聚集索引?

| 动作描述           | 聚集索引 | 非聚集索引 |
| ------------------ | -------- | ---------- |
| 列经常被分组排序   | 可使用   | 可使用     |
| 返回某范围内的数据 | 可使用   | 不可       |
| 一个或极少不同值   | 不可     | 不可       |
| 小数目的不同值     | 可使用   | 不可       |
| 大数目的不同值     | 不可     | 可使用     |
| 频繁更新的列       | 不可     | 可使用     |
| 外键列             | 可使用   | 可使用     |
| 主键列             | 可使用   | 可使用     |
| 频繁修改索引列     | 不可     | 可使用     |

### 八、limit 1000000 加载很慢的话，你是怎么解决的呢？

```sql
CREATE TABLE `users` (
  `id` bigint(20) NOT NULL AUTO_INCREMENT,
  `username` varchar(255) DEFAULT NULL,
  `email` varchar(255) DEFAULT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=1000001 DEFAULT CHARSET=utf8;

// 如果列较少，可以创建覆盖索引，直接全查，走索引快得很
CREATE INDEX idx_users_id_username_email ON users(id, username, email);

SELECT id, username, email FROM users ORDER BY id LIMIT 1000000, 10;
```

##### 方案一：如果id是连续的，可以分批循环查询，返回上次查询的最大记录（偏移量），再往下limit。（如应用市场，查询一百张appmarket表）

```mysql
select id,username from users where id > （上一次循环查询的最大id） limit 1000
```

##### 方案二：在业务允许的条件下，限制页数

##### 方案三：order by + 索引 （id为索引）

```mysql
select id,username from users order by id limit 1000000，10
SELECT a.* FROM employee a, (select id from employee where 条件 LIMIT 1000000,10 ) b where a.id=b.id
```

##### 方案四：使用分区表，你可以按照ID的范围来分区你的表。然后，你的查询可以只扫描一个分区，而不是整个表。

### 九、如何选择合适的分布式主键方案?

- 数据库自增长序列或者字段
- uuid
- redis生成id，所有服务都依赖于redis生成id
- twitter的snowflake算法（雪花算法）
- 利用zookeeper生成唯一id
- monogDB的objectId

### 十、大表查询优化方案？

1. 优化shema、sql语句+索引
2. memcached，redis缓存，内存缓存，多级缓存插件
3. 主从复制，读写分离
4. 分库分表，sharding分片

### 十一、事务隔离级别

1. 读未提交（脏读）
2. 读已提交（不可重读）
3. 可重复读（幻读）
4. 串行化

##### 	mysql默认的事务隔离级别是可重复读

### 十二、什么是幻读、脏读、不可重复读？

- 脏读：事务A、B交替执行，事务A被事务B干扰到了，因为事务A读取到事务B未提交的数据，就是脏读
- 不可重读：在一个事务范围内，两个相同的查询，读取同一条记录，却返回了不同数据
- 幻读：事务A查询一个范围的结果集，另一个并发事务B往这个范围中插入/删除了值，并悄悄提交，然后事务A再次查询相同范围，两次读到的结果集不一致，这既是幻读

### 十三、在高并发情况下，如何做到安全的修改同一行数据？

​	要安全的修改同一行数据，就要保证一个线程在修改时，其他线程无法更新该条记录，一版有【乐观锁】和【悲观锁】两种方案

1. 乐观锁的思想基于，当线程请求过来，先放过去执行，如果看到别的线程没修改过，就可以修改成功，如果别的线程修改过，就失败或者重试，实现方式一般基于版本号机制或CAS算法实现

   场景：

   - 高响应效率
   - 冲突频率低，乐观锁会导致多次失败
   - 会导致用户重新执行

   ```mysql
   1.select version where id = 1; // version = "1.0"
   
   2.update user set username = "shybo" where id = 1 and version = "1.0"
   ```

2. 乐观锁的思想其实就是排他锁，当一个线程在执行时，其他线程阻塞

   ```mysql
   // 这条sql锁定了user表中符合检索条件 username = "shybo" 的记录，本次事务提交前，其他线程无法更改
   select * from user where username = "shybo" for update
   ```

   - 冲突频率高
   - 重试代价大时，选悲观锁，因为悲观锁会阻塞等待

### 十四、你在工作中如何优化sql，怎么查看执行计划（explain）

1. show status 命令了解各种sql的执行频率
2. 通过慢查询日志定位那些执行效率低的sql
3. explain分析sql，分析sql是否走了索引，影响行数

### 十五、select for update有什么含义，会锁表还是锁行还是其他？

##### 	select for updata 含义

​	select查询语句是不会加锁的，但是select for update除了有查询的作用外，还会加速，至于加了行锁还是表锁，这就要看是不是使用了索引/主键，没用到索引/主键的话就是表锁，用到了就是行锁

### 十六、mysql事务的四大特性以及实现原理

1. 原子性：事务作为一个整体被执行，包含其中的对数据的操作，要么全部执行，要么都不执行
   - 使用undo log实现，如果事务执行过程中出错或者用户执行了回滚，系统通过undo log日志返回事务开始前的状态
2. 一致性：指在事务开始之前和结束之后，数据不会被破坏，假如a账户给b账户转账10元，不管成功与否，a+b的总金额是不会变的
   - 通过回滚、恢复以及并发情况下的隔离性，从而实现一致
3. 隔离性：多个事务并发访问时，事务之间是相互隔离的，即一个事务不影响其他事务的运行，事务之间井水不犯河水
   - 通过锁以及mvcc隔离
4. 持久性：事务完成后，该事务对数据库所做的操作，将持久的保存在数据库（磁盘）中
   - 使用redo log实现，只要redo log日志持久化了，当系统崩溃，即可通过redo log把数据恢复

### 十七、如果某个表有近千万条数据，crud比较慢，如何优化？

- 分库分表（水平分表、垂直分表，切分规则hash等）
- 分库分表中间件
- 优化表结构，索引设计，查询不要select *，只选必要字段

### 十八、如何写sql能够有效的使用到复合索引

##### 	复合索引也叫组合索引，用户可以在多个列上建立索引

```mysql
// 索引为 (k1,k2,k3)相当于k1、(k2,k3)、(k1,k2,k3)，最左前缀原则
select * from user where k1 = A AND k2 = b AND k3 = C
```

​	需要严格遵循sql条件的顺序，确保复合最左前缀原则

### 十九、数据库自增主键可能遇到什么问题。

​	使用自增主键对数据库做分库分表，可能出现主键重复，自增主键会产生表锁，做大数据迁移会不友好，自增主键还可能用完

### 二十、mvcc熟悉吗，它的底层原理？

​	mvcc，多版本并发控制，它是通过读取历史版本的数据，来降低并发事务冲突，从而提高并发性的一种机制

##### 	需要关注的知识点:

1. 事务版本号
2. 表的隐藏列
3. undo log
4. read view

### 二十一、数据库中间件了解吗，sharding jdbc，mycat？

​	sharding-jdbc是基于jdbc驱动，无需额外的proxy，因此也无需关注proxy本身的高可用，mycat是基于proxy，它复写了mysql的协议，将mycat server伪装成一个mysql数据库，而sharding-jdbc是基于jdbc接口实现，是以jar包的形式提供轻量级服务
