# MySQL数据库经典面试题解析

### 一、MySQL 索引使用有哪些注意事项呢？

​	可以从三个维度回答这个问题：索引哪些情况会失效，索引不适合哪些场景，索引规则

- ##### 索引哪些情况会失效

  - 查询条件包含or，可能导致索引失效
  - 字符串类型，where时，如果不用引号括起来，会导致类型转换，从而索引失效
  - like以通配符 % 开头的索引会失效
  - 使用联合索引，查询时条件列不是联合索引中的一个列。不符合最左前缀原则，索引失效
  - 在索引列上使用mysql内置函数，导致失效
  - 对索引列使用运算符（+、-、*、/）
  - 对索引列使用（!=、<>、not in）
  - 对索引列使用is null、is not null
  - 连接查询，查询关联的字段编码格式不一样
  - 当mysql判断全表扫描比使用索引快时，则不使用索引

- ##### 索引不适合哪些场景

  - 全表数据量少，建索引得不偿失
  - 更新频繁的字段
  - 区分度低的字段（如性别，平均分）

- ##### 索引的一些潜规则

  - 索引覆盖
  - 回表
  - 索引结构
  - 最左前缀原则
  - 索引下推

### 二、MySQL 遇到过死锁问题吗，你是如何解决的？

##### 	排查死锁的流程一般如下：

- 查看死锁日志show engine innodb status
- 找出死锁sql
- 分析sql加锁情况
- 模拟死锁案发
- 分析死锁日志
- 分析死锁结果

### 三、日常工作中你是如何优化sql的?

1. 对查询频繁的字段上索引
2. 避免返回不必要的数据，只select必要数据
3. 适当分批量查询
4. 优化sql结构
5. 分库分表
6. 读写分离
7. 不怎么更新的数据加载到内存，高频访问数据做缓存

### 四、说说你是怎么设计分库与分表的

- 水平分库：以字段（如cid）为依据，按照一定策略（hash、range等），将一个库中的数据拆分到多个库中
- 水平分表：以字段（如cid）为依据，按照一定策略（hash、range等），将一个表中的数据拆分到多个表中
- 垂直分库：以表为依据，按照业务归属不同，把一个库中的表拆到各自业务的库中
- 垂直分表：以字段为依据，按照字段的活跃性，将表中字段拆到不同的表（主表和扩展表），例如（appinfo和appinfoExtend）

##### 	常用分库分表中间件：

1. sharding-jdbc（当当）
2. Mycat
3. TDDL（淘宝）
4. Oceanus（58同城）
5. vitess（谷歌）
6. Atlas（奇虎360）

##### 	分库分表可能会遇到的问题

1. 事务问题：需要分布式事务
2. 跨节点join问题，需要分两次查询才能解决
3. 跨节点的count,order by,group by以及聚合函数问题：分别在各个节点上得到结果后在<u>内存进行合并</u>。
4. 数据迁移，容量规划，扩容等问题
5. id问题，数据库切分后不能按照数据库自身的主键生成机制了，可以考虑雪花id或者uuid，或者自定义复合主键
6. 跨分片的排序分页问题

### 五、InnoDB与MyISAM的区别

- InnoDB支持事务，MyISAM不支持事务
- InnoDB支持外键，MyISAM不支持外键
- InnoDB支持MVVC（多版本并发控制），MyISAM不支持
- select count(*) from table时，MyISAM更快，因为它有一个变量保存了整个表的总行数，可以直接读取，InnoDB需要全表扫描
- mysql5.7以前，innoDB不支持全文索引，MyISAM支持全文索引
- InnoDB支持表、行级锁，而MyISAM仅支持表锁
- InnoDB必须要有主键，而MyISAM可以没有
- InnoDB表需要更多的内存和存储，而MyISAM可被压缩，存储空间小
- InnoDB表按主键大小有序插入，MyISAM记录插入顺序则是，按记录插入顺序保存
- InnoDB提供了回滚、提交事务、崩溃恢复能力，与MyISAM比，InnoDB写的效率差一点，并且会占用更多磁盘空间用来保存索引和数据
- InnoDB属于索引组织表，使用共享表空间和多表空间存储数据，MyISAM用.frm、.MYD、.MTI来存储表定义、数据和索引

### 六、数据库索引的原理，为什么要用B+树，为什么不用二叉树？

​	可以从多个维度看这个问题，查询是否够快，效率是否稳定，存储数据多少，以及查找磁盘次数，为什么不是二叉树，为什么不是平衡二叉树，为什么不是B树，偏偏是B+树呢？

##### 	为什么不是一般的二叉树？

​	如果二叉树特殊化（退化，只有左孩子或者只有右孩子）为一个链表，相当于全表扫描，平衡二叉树相比于二叉查找树而言，查找效率更稳定，总体速度也快

##### 	为什么不是平衡二叉树？

​	在内存比在磁盘的数据，查询效率高很多，如果用平衡二叉树作为索引结构，每查找一次数据就要从磁盘读一个节点，也就是磁盘块，但是平衡二叉树每个节点只存储一个键值和数据，如果是B树，可以存储更多的节点数据，树的高度也会降低，因此读取磁盘的次数就变少了，查询效率嘎嘎提高

##### 	为什么不是B树？

1. B+树非叶子节点上是不存储数据的，仅存储简直，而B树节点不仅存储键值，也存储数据，innodb中页的默认大小是16kb，如果不存储数据，那么就会存储更多的键值，相应树的阶树（节点的子节点数）就会更大，树就会更矮更胖，如此一来我们进行磁盘的i/o次数也会减少，查询效率会更高
2. B+树索引的所有数据均存储在叶子节点，而且数据是按照顺序排列的，链表连着叶子节点，所以B+树能更好支持范围查找，排序查找，分组查找与去重

