# MySQL数据库经典面试题解析

### 一、MySQL 索引使用有哪些注意事项呢？

​	可以从三个维度回答这个问题：索引哪些情况会失效，索引不适合哪些场景，索引规则

- ##### 索引哪些情况会失效

  - 查询条件包含or，可能导致索引失效
  - 字符串类型，where时，如果不用引号括起来，会导致类型转换，从而索引失效
  - like以通配符 % 开头的索引会失效
  - 使用联合索引，查询时条件列不是联合索引中的一个列。不符合最左前缀原则，索引失效
  - 在索引列上使用mysql内置函数，导致失效
  - 对索引列使用运算符（+、-、*、/）
  - 对索引列使用（!=、<>、not in）
  - 对索引列使用is null、is not null
  - 连接查询，查询关联的字段编码格式不一样
  - 当mysql判断全表扫描比使用索引快时，则不使用索引

- ##### 索引不适合哪些场景

  - 全表数据量少，建索引得不偿失
  - 更新频繁的字段
  - 区分度低的字段（如性别，平均分）

- ##### 索引的一些潜规则

  - 索引覆盖
  - 回表
  - 索引结构
  - 最左前缀原则
  - 索引下推

### 二、MySQL 遇到过死锁问题吗，你是如何解决的？

##### 	排查死锁的流程一般如下：

- 查看死锁日志show engine innodb status
- 找出死锁sql
- 分析sql加锁情况
- 模拟死锁案发
- 分析死锁日志
- 分析死锁结果

### 三、日常工作中你是如何优化sql的?

1. 对查询频繁的字段上索引
2. 避免返回不必要的数据，只select必要数据
3. 适当分批量查询
4. 优化sql结构
5. 分库分表
6. 读写分离
7. 不怎么更新的数据加载到内存，高频访问数据做缓存

### 四、说说你是怎么设计分库与分表的

- 水平分库：以字段（如cid）为依据，按照一定策略（hash、range等），将一个库中的数据拆分到多个库中
- 水平分表：以字段（如cid）为依据，按照一定策略（hash、range等），将一个表中的数据拆分到多个表中
- 垂直分库：以表为依据，按照业务归属不同，把一个库中的表拆到各自业务的库中
- 垂直分表：以字段为依据，按照字段的活跃性，将表中字段拆到不同的表（主表和扩展表），例如（appinfo和appinfoExtend）

##### 	常用分库分表中间件：

1. sharding-jdbc（当当）
2. Mycat
3. TDDL（淘宝）
4. Oceanus（58同城）
5. vitess（谷歌）
6. Atlas（奇虎360）

##### 	分库分表可能会遇到的问题

1. 事务问题：需要分布式事务
2. 跨节点join问题，需要分两次查询才能解决
3. 跨节点的count,order by,group by以及聚合函数问题：分别在各个节点上得到结果后在<u>内存进行合并</u>。
4. 数据迁移，容量规划，扩容等问题
5. id问题，数据库切分后不能按照数据库自身的主键生成机制了，可以考虑雪花id或者uuid，或者自定义复合主键
6. 跨分片的排序分页问题

### 五、InnoDB与MyISAM的区别

- InnoDB支持事务，MyISAM不支持事务
- InnoDB支持外键，MyISAM不支持外键
- InnoDB支持MVVC（多版本并发控制），MyISAM不支持
- select count(*) from table时，MyISAM更快，因为它有一个变量保存了整个表的总行数，可以直接读取，InnoDB需要全表扫描
- mysql5.7以前，innoDB不支持全文索引，MyISAM支持全文索引
- InnoDB支持表、行级锁，而MyISAM仅支持表锁
- InnoDB必须要有主键，而MyISAM可以没有
- InnoDB表需要更多的内存和存储，而MyISAM可被压缩，存储空间小
- InnoDB表按主键大小有序插入，MyISAM记录插入顺序则是，按记录插入顺序保存
- InnoDB提供了回滚、提交事务、崩溃恢复能力，与MyISAM比，InnoDB写的效率差一点，并且会占用更多磁盘空间用来保存索引和数据
- InnoDB属于索引组织表，使用共享表空间和多表空间存储数据，MyISAM用.frm、.MYD、.MTI来存储表定义、数据和索引

### 六、数据库索引的原理，为什么要用B+树，为什么不用二叉树？

​	可以从多个维度看这个问题，查询是否够快，效率是否稳定，存储数据多少，以及查找磁盘次数，为什么不是二叉树，为什么不是平衡二叉树，为什么不是B树，偏偏是B+树呢？

##### 	为什么不是一般的二叉树？

​	如果二叉树特殊化（退化，只有左孩子或者只有右孩子）为一个链表，相当于全表扫描，平衡二叉树相比于二叉查找树而言，查找效率更稳定，总体速度也快

##### 	为什么不是平衡二叉树？

​	在内存比在磁盘的数据，查询效率高很多，如果用平衡二叉树作为索引结构，每查找一次数据就要从磁盘读一个节点，也就是磁盘块，但是平衡二叉树每个节点只存储一个键值和数据，如果是B树，可以存储更多的节点数据，树的高度也会降低，因此读取磁盘的次数就变少了，查询效率嘎嘎提高

##### 	为什么不是B树？

1. B+树非叶子节点上是不存储数据的，仅存储简直，而B树节点不仅存储键值，也存储数据，innodb中页的默认大小是16kb，如果不存储数据，那么就会存储更多的键值，相应树的阶树（节点的子节点数）就会更大，树就会更矮更胖，如此一来我们进行磁盘的i/o次数也会减少，查询效率会更高
2. B+树索引的所有数据均存储在叶子节点，而且数据是按照顺序排列的，链表连着叶子节点，所以B+树能更好支持范围查找，排序查找，分组查找与去重

### 七、聚集索引与非聚集索引区别

1. 一个表中只能有一个聚集索引，而非聚集索引一个表可以存在多个
2. 聚集索引，索引中键值的逻辑顺序决定了表中相应行的物理顺序；非聚集索引，索引的逻辑顺序与磁盘上行的物理存储顺序不同
3. 索引通过二叉树的数据结构来描述，我们可以这么理解聚集索引：索引的叶子节点就是数据节点，而非聚集索引的叶子节点仍然是索引节点，只不过有一个指针指向对应的数据块。
4. 聚集索引物理存储按照索引排序，非聚集索引物理存储不按照索引排序

​	何时使用聚集索引和非聚集索引?

| 动作描述           | 聚集索引 | 非聚集索引 |
| ------------------ | -------- | ---------- |
| 列经常被分组排序   | 可使用   | 可使用     |
| 返回某范围内的数据 | 可使用   | 不可       |
| 一个或极少不同值   | 不可     | 不可       |
| 小数目的不同值     | 可使用   | 不可       |
| 大数目的不同值     | 不可     | 可使用     |
| 频繁更新的列       | 不可     | 可使用     |
| 外键列             | 可使用   | 可使用     |
| 主键列             | 可使用   | 可使用     |
| 频繁修改索引列     | 不可     | 可使用     |

### 八、limit 1000000 加载很慢的话，你是怎么解决的呢？

```sql
CREATE TABLE `users` (
  `id` bigint(20) NOT NULL AUTO_INCREMENT,
  `username` varchar(255) DEFAULT NULL,
  `email` varchar(255) DEFAULT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=1000001 DEFAULT CHARSET=utf8;

// 如果列较少，可以创建覆盖索引，直接全查，走索引快得很
CREATE INDEX idx_users_id_username_email ON users(id, username, email);

SELECT id, username, email FROM users ORDER BY id LIMIT 1000000, 10;
```

##### 方案一：如果id是连续的，可以分批循环查询，返回上次查询的最大记录（偏移量），再往下limit。（如应用市场，查询一百张appmarket表）

```mysql
select id,username from users where id > （上一次循环查询的最大id） limit 1000
```

##### 方案二：在业务允许的条件下，限制页数

##### 方案三：order by + 索引 （id为索引）

```mysql
select id,username from users order by id limit 1000000，10
SELECT a.* FROM employee a, (select id from employee where 条件 LIMIT 1000000,10 ) b where a.id=b.id
```

##### 方案四：使用分区表，你可以按照ID的范围来分区你的表。然后，你的查询可以只扫描一个分区，而不是整个表。

### 九、如何选择合适的分布式主键方案?

- 数据库自增长序列或者字段
- uuid
- redis生成id，所有服务都依赖于redis生成id
- twitter的snowflake算法（雪花算法）
- 利用zookeeper生成唯一id
- monogDB的objectId

### 十、大表查询优化方案？

1. 优化shema、sql语句+索引
2. memcached，redis缓存，内存缓存，多级缓存插件
3. 主从复制，读写分离
4. 分库分表，sharding分片

### 十一、事务隔离级别

1. 读未提交（脏读）
2. 读已提交（不可重读）
3. 可重复读（幻读）
4. 串行化

##### 	mysql默认的事务隔离级别是可重复读

### 十二、什么是幻读、脏读、不可重复读？

- 脏读：事务A、B交替执行，事务A被事务B干扰到了，因为事务A读取到事务B未提交的数据，就是脏读
- 不可重读：在一个事务范围内，两个相同的查询，读取同一条记录，却返回了不同数据
- 幻读：事务A查询一个范围的结果集，另一个并发事务B往这个范围中插入/删除了值，并悄悄提交，然后事务A再次查询相同范围，两次读到的结果集不一致，这既是幻读
